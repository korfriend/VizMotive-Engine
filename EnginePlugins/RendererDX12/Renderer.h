#pragma once
#include "Common/Backend/GBackendDevice.h"
#include "Components/GComponents.h"

static const uint32_t SHADERTYPE_BIN_COUNT = (uint32_t)vz::MaterialComponent::ShaderType::COUNT;

namespace vz::graphics
{
	// global resources //
	//	will be used across differenct combinations of scenes and cameras

	// shaders
	enum SHADERTYPE
	{
		// vertex shaders
		VSTYPE_DEBUG,
		VSTYPE_COMMON,
		VSTYPE_SIMPLE,
		VSTYPE_VERTEXCOLOR,

		// pixel shaders
		PSTYPE_DEBUG,	// debug output (to final render target)
		PSTYPE_SIMPLE,	// no shading (to final render target)
		PSTYPE_VERTEXCOLOR,

		PS_PHONG_FORWARD_BEGIN,
		PS_PHONG_FORWARD_END = PS_PHONG_FORWARD_BEGIN + SHADERTYPE_BIN_COUNT,
		//PS_PHONG_FORWARD_TRANSPARENT_BEGIN,
		//PS_PHONG_FORWARD_TRANSPARENT_END = PS_PHONG_FORWARD_TRANSPARENT_BEGIN + SHADERTYPE_BIN_COUNT,
		//PS_PHONG_TRANSPARENT_BEGIN,
		//PS_PHONG_TRANSPARENT_END = PS_PHONG_TRANSPARENT_BEGIN + SHADERTYPE_BIN_COUNT,
		//PS_PHONG_TRANSPARENT_TRANSPARENT_BEGIN,
		//PS_PHONG_TRANSPARENT_TRANSPARENT_END = PS_PHONG_TRANSPARENT_TRANSPARENT_BEGIN + SHADERTYPE_BIN_COUNT,

		SHADERTYPE_COUNT,
	};

	// input layouts
	enum ILTYPES
	{
		ILTYPE_VERTEXCOLOR,
		ILTYPE_POSITION,
		ILTYPE_COUNT
	};

	// rasterizer states
	enum RSTYPES
	{
		RSTYPE_FRONT,
		RSTYPE_BACK,
		RSTYPE_DOUBLESIDED,
		RSTYPE_WIRE,
		RSTYPE_WIRE_SMOOTH,
		RSTYPE_WIRE_DOUBLESIDED,
		RSTYPE_WIRE_DOUBLESIDED_SMOOTH,
		RSTYPE_SHADOW,
		RSTYPE_SHADOW_DOUBLESIDED,
		RSTYPE_OCCLUDEE,
		RSTYPE_VOXELIZE,
		RSTYPE_SKY,
		RSTYPE_COUNT
	};

	// depth-stencil states
	enum DSSTYPES
	{
		DSSTYPE_DEFAULT,
		DSSTYPE_TRANSPARENT,
		DSSTYPE_SHADOW,
		DSSTYPE_DEPTHDISABLED,
		DSSTYPE_DEPTHREAD,
		DSSTYPE_DEPTHREADEQUAL,
		DSSTYPE_ENVMAP,
		DSSTYPE_CAPTUREIMPOSTOR,
		DSSTYPE_WRITEONLY,
		DSSTYPE_HOLOGRAM,
		DSSTYPE_COPY_STENCIL_BIT_0,
		DSSTYPE_COPY_STENCIL_BIT_1,
		DSSTYPE_COPY_STENCIL_BIT_2,
		DSSTYPE_COPY_STENCIL_BIT_3,
		DSSTYPE_COPY_STENCIL_BIT_4,
		DSSTYPE_COPY_STENCIL_BIT_5,
		DSSTYPE_COPY_STENCIL_BIT_6,
		DSSTYPE_COPY_STENCIL_BIT_7,
		DSSTYPE_COPY_STENCIL_BIT_8,
		DSSTYPE_COUNT
	};

	enum BSTYPES
	{
		BSTYPE_OPAQUE,
		BSTYPE_TRANSPARENT,
		BSTYPE_ADDITIVE,
		BSTYPE_PREMULTIPLIED,
		BSTYPE_COLORWRITEDISABLE,
		BSTYPE_MULTIPLY,
		BSTYPE_TRANSPARENTSHADOW,
		BSTYPE_COUNT
	};

	// buffers
	enum BUFFERTYPES
	{
		BUFFERTYPE_FRAMECB,
		BUFFERTYPE_COUNT
	};

	enum SAMPLERTYPES
	{
		// Can be changed by user
		SAMPLER_OBJECTSHADER,

		// Persistent samplers
		// These are bound once and are alive forever
		SAMPLER_LINEAR_CLAMP,
		SAMPLER_LINEAR_WRAP,
		SAMPLER_LINEAR_MIRROR,
		SAMPLER_POINT_CLAMP,
		SAMPLER_POINT_WRAP,
		SAMPLER_POINT_MIRROR,
		SAMPLER_ANISO_CLAMP,
		SAMPLER_ANISO_WRAP,
		SAMPLER_ANISO_MIRROR,
		SAMPLER_CMP_DEPTH,

		SAMPLER_COUNT,
	};

	enum RENDERPASS
	{
		RENDERPASS_FORWARD,
		RENDERPASS_FORWARD_WIRE,
		//RENDERPASS_FORWARD_WIRE_THICK,
		//RENDERPASS_FRAGCOUNT, // used for transparency
		//RENDERPASS_DEFERRED,
		RENDERPASS_COUNT
	};

	enum DEBUGRENDERING
	{
		DEBUGRENDERING_GRID,
		DEBUGRENDERING_CUBE,
		DEBUGRENDERING_CUBE_DEPTH,
		DEBUGRENDERING_LINES,
		DEBUGRENDERING_LINES_DEPTH,
		DEBUGRENDERING_TRIANGLE_SOLID,
		DEBUGRENDERING_TRIANGLE_WIREFRAME,
		DEBUGRENDERING_TRIANGLE_SOLID_DEPTH,
		DEBUGRENDERING_TRIANGLE_WIREFRAME_DEPTH,
		DEBUGRENDERING_EMITTER,
		DEBUGRENDERING_COUNT
	};

	namespace initializer
	{
		void SetUpStates();
		void LoadBuffers();
	}

	namespace shader
	{
		bool LoadShader(
			ShaderStage stage,
			Shader& shader,
			const std::string& filename,
			ShaderModel minshadermodel = graphics::ShaderModel::SM_6_0,
			const std::vector<std::string>& permutation_defines = {}
		);

		void LoadShaders();
	}
}